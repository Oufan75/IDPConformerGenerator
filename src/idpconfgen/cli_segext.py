"""
Extract secondary structure protein segments from PDBs.

Requires a *.dssp file as generated by `idpconfgen ssext` CLI.

USAGE:

idpcfongen segext PDBS_FOLDER DSSPFILE -d OUTPUTFOLDER -s [L/H/E/A]
"""
import argparse
from functools import partial

from idpconfgen import Path, log
from idpconfgen.core import definitions as DEFS
from idpconfgen.libs import libcli, libio, libstructure, libparse, libpdb
from idpconfgen.logger import S, T, init_files


LOGFILESNAMES = '.idpconfgen_segext'

_name = 'segsplit'
_help = 'Split PDB into secondary structure segments.'
_prog, _des, _us = libcli.parse_doc_params(__doc__)

ap = libcli.CustomParser(
    prog=_prog,
    description=libcli.detailed.format(_des),
    usage=_us,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    )

libcli.add_argument_pdb_files(ap)

ap.add_argument(
    'sscalc_file',
    help='The DSSP file as saved by IDPConfGen SSCALC CLI',
    )

libcli.add_argument_destination_folder(ap)

ap.add_argument(
    '-s',
    '--structure',
    help=(
        'The secondary structure type to extract. '
        'Defaults to \'all\'. '
        'A subfolder is created for each secondary structure type'
        ),
    default='all',
    )

ap.add_argument(
    '-a',
    '--atoms',
    help=(
        'List of atom names to save in the selection.\n'
        'Defaults to `N`, `CA`, and `C`.'
        ),
    default='all',  # ('N', 'CA', 'C'),
    nargs='+',
    )


def filter_dssp_segments(seg, required='all'):
    if required == 'all':
        return True
    else:
        return seg == required


def main(
        pdb_files,
        sscalc_file,
        atoms,
        minimum_size=4,
        destination=None,
        structure='all',
        func=None,
        chunks=5000,
        ):

    ssdata = read_dictionary_from_disk(sscalc_file)
    pdbs2operate = FileReaderIterator(pdb_files, ext='.pdb')

    execute = partial(pool_function_in_chunks(
        segment_split,
        pdbs2operate,
        ncores=ncores,
        chunks=chunks,
        ssdata=ssdata,
        structure=structure,
        ))

    for run in execute:
        save_pairs_to_disk(run, destination=destination)






def segment_split(pdbid, ssdata):
    pdbname = pdbid[0]
    pdbdata = pdbid[1]
    pdbdd = ssdata[pdbname]

    ss_identified = set(pdbdd['dssp'])


    slice_jump = len(atoms)
    minimum_size = slice_jump * minimum_size



    for pdbid in pdb_list:

        log.info(S(f'working with {pdbid}'))

        dssp_segments = libparse.group_by(dssp_data[pdbid.stem].translate(DEFS.dssp_trans))

        pdbdata = libstructure.Structure(pdbid.read_text())
        pdbdata.build()
        pdbdata.add_filter(lambda x: x[libstructure.col_name] in atoms)

        counter = 1

        user_required_dssp_segments = filter(
            lambda x: x[0] == structure,
            dssp_segments,
            )

        for segtype, segslice in user_required_dssp_segments:

            res_slice = slice(
                segslice.start * slice_jump,
                segslice.stop * slice_jump,
                None,
                )

            if res_slice.stop - res_slice.start < minimum_size:
                continue

            to_write = list(pdbdata.filtered_atoms)[res_slice]

            libstructure.write_PDB(
                libstructure.structure_to_pdb(to_write),
                Path(dest, f'{pdbid.stem}_{segtype}_{counter}.pdb'),
                )
            counter += 1




    return


if __name__ == '__main__':
    maincli()
